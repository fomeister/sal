package jcu.sal.client.gui;

import java.rmi.RemoteException;

import jcu.sal.common.CommandFactory;
import jcu.sal.common.Constants;
import jcu.sal.common.Response;
import jcu.sal.common.StreamID;
import jcu.sal.common.CommandFactory.Command;
import jcu.sal.common.agents.SALAgent;
import jcu.sal.common.events.ClientEventHandler;
import jcu.sal.common.exceptions.ConfigurationException;
import jcu.sal.common.exceptions.NotFoundException;
import jcu.sal.common.exceptions.SALDocumentException;
import jcu.sal.common.exceptions.SensorControlException;

public interface ClientController {
	
	
	/**
	 * This method creates a client stub connecting to a remote RMI SAL agent and returns a reference to it.
	 * @param rmiName the unique RMI name used to identify this RMI client
	 * @param ipAddress the IP address of the SAL agent RMI registry
	 * @param ourIpAddress the IP address of this client's RMI registry
	 * @return a reference to a remote RMI SAL agent
	 * @throws ConfigurationException if the given unique RMI name is already taken
	 * @throws RemoteException if there is an RMI error while connecting to the agent.
	 */
	public SALAgent rmiConnect(String rmiName, String ipAddress, String ourIpAddress) throws ConfigurationException, RemoteException;
	
	/**
	 * This method creates a client stub connecting to a remote RMI SAL agent and returns a reference to it.
	 * @param a the RMI SAL agent
	 * @throw {@link ClassCastException} if the given SAL agent is not an RMI agent
	 */
	public void rmiDisonnect(SALAgent a);

	/**
	 * This method releases a SAL agent. 
	 * @param a a reference to an SAL agent.
	 */
	public void disconnect(SALAgent a);
	
	
	/*
	 * Sensor-related methods
	 */
	
	/**
	 * This method instantiate a new sensor given its SML description. The SML description must be generated by
	 * calling the <code>getXMLString()</code> on an <code>SMLdescription</code> object.The returned value is a 
	 * string representation of the sensor identifier. If one is specified in the XML document, it will be ignored
	 * and replaced with a new one (the returned value). 
	 * @param a the SAL agent where the sensor must be added
	 * @param xml the sensor's XML configuration document. It is generated by calling <code>SMLDescription.getXMLString()</code>
	 * @return a string representing the sensor identifier
	 * @throws SALDocumentException if the SML document is malformed
	 * @throws ConfigurationException if the sensor cant be instantiated because of invalid configuration information
	 */
	public String addSensor(SALAgent a, String xml) throws SALDocumentException, ConfigurationException;
	
	/**
	 * This method removes a sensor with the given identifier. Its configuration information is also removed from the
	 * configuration file.
	 * @param a the SAL agent where the sensor must be removed
	 * @param sid the sensor identifier
	 * @throws NotFoundException if the given sensor ID doesnt match any existing sensor
	 */
	public void removeSensor(SALAgent a, String sid) throws NotFoundException;
	
	/**
	 * This method returns an XML document containing the configuration of all currently active sensors.
	 * An active sensor is one that has been connected at least once since startup. Note that an active
	 * sensor may not be currently connected (for instance if its protocol has been removed). The returned string
	 * can be used to create a <code>SMLDescriptions</code> object which facilitate the parsing of the XML document.
	 * @param a the SAL agent from which the sensor list is to be retrieved. 
	 * @return the configuration of all active sensors as an XML document, from which a <code>SMLDescriptions</code>
	 * object can be created to facilitate parsing.
	 */
	public String listActiveSensors(SALAgent a);
	
	/**
	 * This method returns an XML document containing the configuration of all known sensors.
	 * A known sensor is one that has its configuration stored in the sensor configuration file 
	 * Known sensors may or may not be currently connected, and may not have been connected at all since
	 * startup. The returned string can be used to create a <code>SMLDescriptions</code> object which facilitate
	 * the parsing of the XML document.
	 * @param a the SAL agent from which the sensor list is to be retrieved. 
	 * @return the configuration of all known sensors as an XML document, from which a <code>SMLDescriptions</code>
	 * object can be created to facilitate parsing.
	 */
	public String listSensors(SALAgent a);
	
	/**
	 * This method returns an SML description document containing the configuration for a given sensor.
	 * The returned string can be used to create a <code>SMLDescriptions</code> object which facilitate the
	 * parsing of the XML document.
	 * @param a the SAL agent from which the sensor list is to be retrieved. 
	 * @return the configuration of the given sensors as an XML document, from which a <code>SMLDescriptions</code>
	 * object can be created to facilitate parsing.
	 * @throws NotFoundException if no sensor matches the given identifier
	 */
	public String listSensor(SALAgent a, String sid) throws NotFoundException;
	
	/**
	 * This method sets up a stream given a sensor and a command.
	 * The command will be sent to the sensor at fixed intervals in time (as specified
	 * in the {@link Command} object), creating a stream of {@link Response}s, sent
	 * back to the client. After setting up the stream, the {@link #startStream(StreamID)}
	 * method must be called with the returned value of this method (a {@link StreamID}), to start
	 * streaming, EXCEPT if the command is to be run only once, in which case, 
	 * the returned {@link StreamID} is null and {@link #startStream(StreamID)} 
	 * will be called automatically. 
	 * @param c the command to be executed. {@link Command}s are created using a 
	 * {@link CommandFactory} object.
	 * @param sid the target sensor identifier
	 * @return a {@link StreamID} which uniquely identifies this stream, or <code>null</codE>
	 * if the command will run only once, in which case, this method will also call 
	 * {@link #startStream(StreamID)}.
	 * @throws NotFoundException if the given sensor id does not match any existing sensor
	 * @throws SensorControlException if there is an error controlling the sensor. If this exception is raised,
	 * the cause of this exception will be linked to it and can be retrieved using <code>getCause()</code>  
	 */
	public StreamID setupStream(SALAgent a, Command c, String sid) throws NotFoundException, SensorControlException;
	
	/**
	 * This method starts a stream previously setup using {@link #setupStream(Command, String)}.
	 * @param streamId the id of the stream as returned by {@link #setupStream(Command, String)}.
	 * @throws NotFoundException if the given stream Id has not been setup prior
	 * to calling this method.
	 */
	public void startStream(SALAgent a, StreamID streamId) throws NotFoundException;
	
	/**
	 * This method stops and deletes a stream previously setup using {@link #setupStream(Command, String)}.
	 * @param streamId the id of the stream as returned by {@link #setupStream(Command, String)}.
	 * @throws NotFoundException if the given stream Id has not been setup prior
	 * to calling this method.
	 */
	public void terminateStream(SALAgent a, StreamID streamId) throws NotFoundException;
	
	/**
	 * This method returns the a string representation of the CML descriptions document for a given sensor.
	 * The returned string can be used to create a <code>CMLDescriptions</code> object to facilitate parsing the
	 * XML document.
	 * @param a the SAL agent which holds the sensor
	 * @param sid the sensor identifier
	 * @return the CML document, from which a <code>CMLDescriptions</code> can be created to facilitate parsing.
	 * @throws NotFoundException if given sensor ID doesnt match any existing sensor
	 */
	public String getCML(SALAgent a,String sid) throws NotFoundException;
	
	/*
	 * Protocols-related methods 
	 */
	
	/**
	 * This method instantiates a new protocol given its PCML protocol configuration document (as generated
	 * by <code>ProtocolConfiguration.getXMLString()</code>). If successful, this method will also store the
	 * protocol's PCML configuration information in the platform configuration file.
	 * @param a the SAL agent where the protocol should be added 
	 * @param xml a string version of the protocol's PCML protocol description document as generated by
	 * <code>ProtocolDesrcription.getXMLString()</code>
	 * @param loadSensors set to true if the sensor configuration file should be checked for sensors associated with 
	 * this protocol and create them.
	 * @throws ConfigurationException if the protocol cant be instantiated because of invalid configuration information
	 * @throws SALDocumentException if the given PCML document is malformed 
	 */
	public void addProtocol(SALAgent a, String xml, boolean loadSensors) throws ConfigurationException, SALDocumentException;
	
	/**
	 * This method removes a protocol given its ID. The protocol is first stopped so commands are no further 
	 * accepted. It then removes all associated sensors and their configuration if <code>removeSensors</code> is set to true.
	 * @param a the SAL agent where the protocol should be removed
	 * @param pid the protocol identifier
	 * @param removeSensor whether or not to remove the sensor configuration associated with this protocol from the config file
	 * @throws NotFoundException if the given protocol ID doesnt match any existing protocols
	 */
	public void removeProtocol(SALAgent a, String pid, boolean removeSensors) throws NotFoundException;
	
	/**
	 * This method lists the configuration of all existing protocols. The returned value is a string
	 * representation of a PCML protocol descriptions document, which can be used to create a 
	 * <code>ProtocolConfigurations</code> object to facilitate parsing.
	 * @param a the SAL agent from which the protocol list must be generated.
	 * @return a string representation of a PCML document listing the protocols configuration, which can be used to create a 
	 * <code>ProtocolConfigurations</code> object to facilitate parsing.
	 */
	public String listProtocols(SALAgent a);
	
	/*
	 * 
	 * Event-handling related methods
	 * 
	 */

	/**
	 * This method registers an event handler. Whenever the producer <code>producerID</code> generates an event, the method
	 * {@link EventHandler#handle(jcu.sal.common.events.Event)} will be called on the given EventHandler <code>eh</code>.
	 * A Producers ID is usually a protocol name. However, three special producers also exist:
	 *  {@link Constants#SENSOR_MANAGER_PRODUCER_ID} which generates
	 * <code>SensorNodeEvent</code> events when sensors are created and deleted, {@link Constants#SENSOR_MANAGER_PRODUCER_ID} which
	 * generates <code>ProtocolListEvent</code> events when protocols are created and deleted, {@link Constants#SENSOR_MANAGER_PRODUCER_ID}
	 * which generates <code>SensorStateEvent</code> events when a sensor is connected or disconnected.  
	 * @param eh an instance of a class implementing the EventHandler interface which will receive events.
	 * @param producerID the identifier of a protocol or the special identifiers "SensorManager", "ProtocolManager" or "SensorState"
	 * @throws NotFoundException if the given producerID doesnt exist
	 */
	public void registerEventHandler(SALAgent a, ClientEventHandler ev, String producerID) throws NotFoundException;
	
	/**
	 * This method unregisters an EventHandler previously registered with <code>registerEventHandler()</code>
	 * @param eh the EventHandler to re be removed
	 * @param producerID the producer to which it is associated
	 * @throws NotFoundException if the handler can not be found/removed
	 */
	public void unregisterEventHandler(SALAgent a, ClientEventHandler ev, String producerID) throws NotFoundException;
}
